<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>小保</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一定要记住“温故知新”">
<meta property="og:type" content="website">
<meta property="og:title" content="小保">
<meta property="og:url" content="https://github.com/henjuese/henjuese.github.io.git/index.html">
<meta property="og:site_name" content="小保">
<meta property="og:description" content="一定要记住“温故知新”">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小保">
<meta name="twitter:description" content="一定要记住“温故知新”">
  
    <link rel="alternate" href="/atom.xml" title="小保" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">小保</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">温故知新</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/henjuese/henjuese.github.io.git"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/15/hello-world/" class="article-date">
  <time datetime="2017-06-15T02:51:54.000Z" itemprop="datePublished">2017-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/15/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/henjuese/henjuese.github.io.git/2017/06/15/hello-world/" data-id="cj3xu2t5a00007wfyb3xx7per" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jvm-jvm" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/08/jvm-jvm/" class="article-date">
  <time datetime="2017-06-08T02:28:49.000Z" itemprop="datePublished">2017-06-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h2 id="jvm-内存管理机制（一）"><a href="#jvm-内存管理机制（一）" class="headerlink" title=" jvm-内存管理机制（一）"></a> jvm-内存管理机制（一）</h2><p>JVM内存区域主要包括如下部分：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区。<br>JVM内存管理也可以理解为jvm运行时数据区，jvm内存主要管理的就是这片内存区域。<br><img src="http://oqumwumio.bkt.clouddn.com/structure.png" alt=""></p>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><h3 id="堆（各线程共享区域）"><a href="#堆（各线程共享区域）" class="headerlink" title="堆（各线程共享区域）"></a>堆（各线程共享区域）</h3><p>1.java虚拟机所管理的内存中最大的一块。java堆时被所有线程共享的一块内存区域，在虚拟机启动时创建。<br>2.此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。（几乎所有的对象实例以及数组都要在堆上分配。<br>3.java堆实GC管理的只要区域，也称为GC堆。<br>4.java堆中还细分未：新生代，老年代；再细分一点有Eden空间，From Survivor空间，To Survivor空间</p>
<h3 id="方法区（各线程共享区域）"><a href="#方法区（各线程共享区域）" class="headerlink" title="方法区（各线程共享区域）"></a>方法区（各线程共享区域）</h3><p>1.各线程共享区域，存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据<br>2.GC很少出现在该区域，主要针对常量池的回收和对类的卸载回收。GC效果不明显但有时候有必须回收该区域</p>
<h3 id="虚拟机栈vm-stack（私有）"><a href="#虚拟机栈vm-stack（私有）" class="headerlink" title="虚拟机栈vm stack（私有）"></a>虚拟机栈vm stack（私有）</h3><p>1.每个方法在执行的同时都会创建一个栈帧用于存储局部变量，操作数栈，动态链接，方法出口等信息，每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程<br>2.如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出stackoverflowError；如果虚拟机可以动态扩展，但是无法申请到足够的内存时，就会抛出outOfMemoryError异常  </p>
<h3 id="本地方法栈（私有）"><a href="#本地方法栈（私有）" class="headerlink" title="本地方法栈（私有）"></a>本地方法栈（私有）</h3><p>虚拟机栈未虚拟机执行java方法提供服务，而本地方法栈未虚拟机使用到的本地方法服务。</p>
<h3 id="程序计数器（私有）"><a href="#程序计数器（私有）" class="headerlink" title="程序计数器（私有）"></a>程序计数器（私有）</h3><p>1.是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。每条线程都需要一个独立的程序计数器，各线程之间互不影响<br>2.字节码解释器选取下一条指令，分支，循环，跳转，异常处理，线程恢复都需要依赖它  </p>
<p>###Java中的常量池<br>java 常量池实际上分为两种形态：静态常量池 和运行时常量池 。</p>
<ul>
<li>所谓静态常量池 ，即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。</li>
<li>而运行时常量池 ，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区 中，我们常说的常量池，就是指方法区中的运行时常量池。</li>
</ul>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>常量池（Constant Pool Table），用于存放编译期生成的各种字面量、符号引用，文字字符串、final变量值、类名和方法名常量，这部分内容将在类加载后存放到方法区的运行时常量池中。它们以数组形式访问，是调用方法、与类联系及类的对象化的桥梁。  </p>
<p>运行时常量池除了存放编译期产生的Class文件的常量外，还可存放在程序运行期间生成的新常量，比较常见增加新常量方法有String类的internd()方法。String.intern()是一个Native方法，它的作用是：如果运行时常量池中已经包含一个等于此String对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此String内容相同的字符串，并返回常量池中创建的字符串的引用。不过JDK7的intern（）方法的实现有所不同，当常量池中没有该字符串时，不再是在常量池中创建与此String内容相同的字符串，而改为在常量池中记录堆中首次出现的该字符串的引用，并返回该引用。  </p>
<p>总结： </p>
<ul>
<li>运行时常量池中的常量，基本来源于各个class文件中的常量池。</li>
<li>程序运行时，除非手动向常量池中添加常量(比如调用intern方法)，否则jvm不会自动添加常量到常量池。  </li>
</ul>
<p>由于运行时常量池在方法区中，我们可以通过jvm参数：-XX:PermSize、-XX:MaxPermSize来设置方法区大小，从而间接限制常量池大小。<br>在jdk8中，移除了方法区，转而用Metaspace区域替代，所以我们需要使用新的jvm参数：-XX:MaxMetaspaceSize</p>
<p><strong>但是，JDK1.7之前运行时常量池是方法区的一部分，JDK1.7及之后版本已经将运行时常量池从方法区中移了出来，在堆（Heap）中开辟了一块区域存放运行时常量池。</strong></p>
<h3 id="Metaspace区？"><a href="#Metaspace区？" class="headerlink" title="Metaspace区？"></a>Metaspace区？</h3><h2 id="HotSpot对象组成介绍"><a href="#HotSpot对象组成介绍" class="headerlink" title="HotSpot对象组成介绍"></a>HotSpot对象组成介绍</h2><p>HotSpot 对象主要有：实例数据，对齐填充，对象头组成。</p>
<h3 id="对象头（Mark-word）"><a href="#对象头（Mark-word）" class="headerlink" title="对象头（Mark word）"></a>对象头（Mark word）</h3><p>存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳，类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>类和对象在运行时的内存里是怎么样的？以及各类型变量、方法在运行时是怎么交互的？</p>
<ul>
<li>在程序运行时类是在方法区，实例对象本身在堆里面。</li>
<li>方法字节码在方法区。</li>
<li>线程调用方法执行时创建栈帧并压栈，方法的参数和局部变量在栈帧的局部变量表。</li>
<li>对象的实例变量和对象一起在堆里，所以各个线程都可以共享访问对象的实例变量。</li>
<li>静态变量在方法区，所有对象共享。字符串常量等常量在运行时常量池。</li>
<li>各线程调用的方法，通过堆内的对象，方法区的静态数据，可以共享交互信息。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/henjuese/henjuese.github.io.git/2017/06/08/jvm-jvm/" data-id="cj3y4c6nh0001nifyhstqaann" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jvm-class" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/05/jvm-class/" class="article-date">
  <time datetime="2017-06-05T03:52:43.000Z" itemprop="datePublished">2017-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="jvm-class类文件结构（三）"><a href="#jvm-class类文件结构（三）" class="headerlink" title="jvm-class类文件结构（三）"></a>jvm-class类文件结构（三）</h1><p>Java虚拟机已经实现了语言无关性的特点。而实现语言无关性的基础是虚拟机和字节码的存储格式，Java虚拟机已经不和包括Java语言在内的任何语言绑定。它只与“class”文件这种特定的二进制文件相关联。在class文件中包含了Java虚拟机指令集和符号表以及若干辅助信息。</p>
<blockquote>
<p>任何编程语言只要能编译成class文件，并且符合class规定的文件格式，就可以在java虚拟机中执行。<br>引用[1]:(class结构图)<a href="http://blog.csdn.net/luanlouis/article/details/39960815" target="_blank" rel="external">http://blog.csdn.net/luanlouis/article/details/39960815</a><br>引用[2]:(class结构说明)<a href="http://blog.csdn.net/u011080472/article/details/51326334" target="_blank" rel="external">http://blog.csdn.net/u011080472/article/details/51326334</a><br>《深入理解java虚拟机》  </p>
</blockquote>
<h2 id="Class类文件结构"><a href="#Class类文件结构" class="headerlink" title="Class类文件结构"></a>Class类文件结构</h2><p>Class文件是一组以8字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑排列在class文件中，中间没有任何分隔符，这使得class文件中存储的内容几乎是全部程序运行的程序。Java虚拟机规范规定，Class文件格式采用类似C语言结构体的伪结构来存储数据，这种结构只有两种数据类型：<strong>无符号数和表</strong>。</p>
<p><strong>无符号数</strong>:属于基本数据类型，主要可以用来描述数字、索引符号、数量值或者按照UTF-8编码构成的字符串值，大小使用u1、u2、u4、u8分别表示1字节、2字节、4字节和8字节。<br><strong>表</strong>:是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有的表都习惯以“_info”结尾。<br>那么表是干嘛的呢？表主要用于描述有层次关系的复合结构的数据，<strong>整个Class文件本质上就是一张表</strong>，比如方法、字段。<br>需要注意的是class文件是没有分隔符的，所以每个的二进制数据类型都是严格定义的。具体的顺序定义如下：  </p>
<p><img src="http://img.blog.csdn.net/20160505210800622" alt="">    </p>
<p>在class文件中，主要分为魔数、Class文件的版本号、常量池、访问标志、类索引（还包括父类索引和接口索引集合）、字段表集合、方法表集合、属性表集合。<br><img src="http://img.blog.csdn.net/20141010133603275" alt=""><br><img src="http://img.blog.csdn.net/20141112171939923" alt=""> </p>
<h2 id="魔数与Class文件版本号"><a href="#魔数与Class文件版本号" class="headerlink" title="魔数与Class文件版本号"></a>魔数与Class文件版本号</h2><p>每个Class文件的头4个字节是魔数，魔数的唯一作用在于确定这个Class文件是否是Java虚拟机接受的Class文件。如gif和jpeg等在文件头中都存在魔术，使用魔术而不是使用扩展名是基于安全性考虑的——扩展名可以随意被改变。Class文件的魔术值为“0xCAFEBABE”（咖啡宝贝？）。<br>紧接着魔数的4个字节是Class文件版本号：版本号又分为次版本号和主版本号。其中前两个字节用于表示次版本号，后两个字节用于表示主版本号。这个的版本号是随着jdk版本的不同而表示不同的版本范围的。如果Class文件的版本号超过虚拟机版本，将被拒绝执行。   </p>
<blockquote>
<p>jdk高版本能执行低版本，但是低版本不能运行高版本代码。52版本不能运行53版本的代码，即是53版本里面写的代码和52版本里面写的代码一样，一旦代码打包编译版本为53就一定不能运行在52版本的jdk服务器上面。因为虚拟机再检查时刚开始检查版本号时，发现版本号大于jdk版本号就直接抛出异常不往下执行了，所以还没有到代码那一步就已经抛出异常了。</p>
</blockquote>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>常量池可以简单理解为<strong>class文件的资源从库</strong>，这种数据类型是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的项目之一。在常量池中主要存放<strong>字面量和符号引用</strong>。<br>常量池的存储结构：<br><img src="http://img.blog.csdn.net/20141010174452984" alt="">  </p>
<ul>
<li>字面量比较接近Java语言层面的常量概念，比如文本字符串、声明为final的常量值等（百度百科的解释是字面量是用双引用号引住的一系列字符）。</li>
<li>符号引用则主要包括三类常量：<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符。</li>
</ul>
</li>
</ul>
<p>常量池能够表示那些信息？<br><img src="http://img.blog.csdn.net/20141011111433728" alt="">  </p>
<p>在常量池中每一项常量都是一个表，在jdk1.7中共有14中常量类型，所以常量池的项目就对应14张表，这14张表的每种类型都不一样。但是有一个共同特点：表开始的第一位都是一个u1类型的标志位，代表这个常量属于哪种类型。<br><img src="http://img.blog.csdn.net/20160505210921426" alt=""><br>需要注意的是，在Class文件中，方法、字段都需要引用CONSTANT-Utf8_info类型的常量，所以这种类型的常量的长度有一定的限制，也就是Java中方法、字段的最大长度。<strong>在CONSTANT-Utf8_info中，其length的值u2，说明Java虚拟机只能编译最大大约64KB的变量或者方法名。超过的话将不会进行编译。</strong>  </p>
<p>使用下面命令查看常量池<br><code>javap -v Simple</code></p>
<h3 id="符号引用与直接引用的关联"><a href="#符号引用与直接引用的关联" class="headerlink" title="符号引用与直接引用的关联"></a>符号引用与直接引用的关联</h3><p><strong>符号引用</strong>是一组符号，用来描述所引用的目标，符号是以任何形式存在的字面量。对于符号引用Java虚拟机并没有严格的限制。规定只需要使用的时候能够无歧义定位到目标就可以。符号引用属于常量池中的内容，那么是不是说符号引用的目标已经加载到内存中了呢？答案是否定的，因为符号引用与虚拟机的内存布局无关，符号引用的目标并不一定已经加载到内存中了。</p>
<p><strong>直接引用</strong>可以是直接指向引用目标的指针、相对偏移量或者是一个能够间接定位到目标的句柄。直接引用是和虚拟机的内存布局有关的，同一个符号引用在不同的虚拟机上翻译的直接引用一般是不同的。如果有了直接引用，那么引用的目标必定是存在内存中的。</p>
<h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p>常量池之后的数据结构是访问标志(access_flags)，占有两个字节，总共16位，这个标志主要用于识别一些类或者接口层次的访问信息，<br>主要包括：这个Class是类还是接口、是否定义public、是否定义abstract类型；如果是类的话是否被声明为final等。具体的标志访问如下：<br><img src="http://img.blog.csdn.net/20160505211102114" alt=""><br><img src="http://img.blog.csdn.net/20141112123015283" alt=""></p>
<h2 id="类索引、父类索引和接口索引集合"><a href="#类索引、父类索引和接口索引集合" class="headerlink" title="类索引、父类索引和接口索引集合"></a>类索引、父类索引和接口索引集合</h2><p>这个数据项主要用于确定这个类的继承关系。</p>
<p>其中类索引和父类索引都是一个u2类型的数据，而接口索引集合是一组u2类型的数据。在Java中由于不允许多继承，所以父类索引是唯一的，但是一个类可以实现多个接口，所以得到的接口索引是一个集合，表示这个类实现了哪些接口。</p>
<h3 id="类索引"><a href="#类索引" class="headerlink" title="类索引"></a>类索引</h3><p>我们知道一般情况下一个Java类源文件经过JVM编译会生成一个class文件，也有可能一个Java类源文件中定义了其他类或者内部类，这样编译出来的class文件就不止一个，但每一个class文件表示某一个类，至于这个class表示哪一个类，便可以通过 类索引 这个数据项来确定。JVM通过类的完全限定名确定是某一个类。 类索引的作用，就是为了指出class文件所描述的这个类叫什么名字。<br>类索引紧接着访问标志的后面，占有两个字节，在这两个字节中存储的值是一个指向常量池的一个索引，该索引指向的是CONSTANT_Class_info常量池项，<br>使用javap -v Simple,常量池中有以下信息：  </p>
<p><img src="http://img.blog.csdn.net/20141112145635992" alt=""><br> 可以看到常量池中的第一项是CONSTANT_Class_info项，它表示一个”com/louis/jvm/Simple”的类名。即类索引是告诉我们这个class文件所表示的是哪一个类。</p>
<p><img src="http://img.blog.csdn.net/20141112150226821" alt=""></p>
<h3 id="父类索引"><a href="#父类索引" class="headerlink" title="父类索引"></a>父类索引</h3><p>Java支持单继承模式，除了java.lang.Object 类除外，每一个类都会有且只有一个父类。class文件中紧接着类索引(this_class)之后的两个字节区域表示父类索引，跟类索引一样，父类索引这两个字节中的值指向了常量池中的某个常量池项CONSTANT_Class_info，表示该class表示的类是继承自哪一个类。</p>
<h3 id="接口索引集合"><a href="#接口索引集合" class="headerlink" title="接口索引集合"></a>接口索引集合</h3><p>由于类实现的接口数目不确定，所以接口索引集合的描述的前部分叫做<strong>接口计数器</strong>（interfaces_count），接口计数器占用两个字节，其中的值表示着这个类实现了多少个接口，紧跟着接口计数器的部分就是接口索引部分了，每一个接口索引占有两个字节，接口计数器的值代表着后面跟着的接口索引的个数。接口索引和类索引和父类索引一样，其内的值存储的是指向了常量池中的常量池项的索引，表示着这个接口的完全限定名。</p>
<h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p>字段表用于描述接口或者类中声明的变量。</p>
<p>字段包括类级变量和实例级变量，但是不包括方法内部声明的局部变量。自然，描述一个字段的信息包括：字段的作用域（public、protected、private）、实例变量与否（static）、可变性（final）、并发可见性（volatile）、可否被序列化（transient）、字段数据类型（基本数据类型、对象、数组）、字段名称。而字段叫什么名字，字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。<br><img src="http://img.blog.csdn.net/20141113103118835" alt=""><br><img src="http://img.blog.csdn.net/20141113150228416" alt=""></p>
<h3 id="可变性（final）"><a href="#可变性（final）" class="headerlink" title="可变性（final）"></a>可变性（final）</h3><p>final访问标志(access_flags)占有两个字节，它能够表述的信息如下所示：<br><img src="http://img.blog.csdn.net/20141113104136471" alt=""></p>
<h3 id="字段的数据类型表示和字段名称表示"><a href="#字段的数据类型表示和字段名称表示" class="headerlink" title="字段的数据类型表示和字段名称表示"></a>字段的数据类型表示和字段名称表示</h3><p>class文件对数据类型的，字段的信息也被存放在一张表中，其字段表包括三种类型：</p>
<ul>
<li>u2类型访问标志（access_flags），其访问标志在access_flags中</li>
<li>u2类型的name_index（字段的简单名称）</li>
<li>u2类型的描述符（descriptor_index）<br>上面出现了简单名称，上文中出现了全限定名，以及这里出现的描述符，三者有什么区别呢？其中全限定名称比较好理解，就是类的完整路径信息。而简单名称则是指没有类型和参数修饰的方法或者字段名称。描述符的主要的作用是描述字段的数据类型、方法的参数列表和返回值。其中我们熟悉的void，在Class文件中用V表示。下面是完整的描述符标志的含义：<br><img src="http://img.blog.csdn.net/20160505211650462" alt=""><br>对于数组类型，每一维度使用一个前置的“[”字符描述，如果是二维数组，那么就有两个“[”符号。比如“java.lang.String[][]”会被记录成“[[Ljava.lang.String;”</li>
</ul>
<p>对于方法，则是按照县参数列表后返回值的顺序进行描述的。比如方法int inc(int a,int[] b,char[][] c,int d)的描述符是“(I[I[[CI)I”。</p>
<h3 id="属性表集合—–静态field字段的初始化"><a href="#属性表集合—–静态field字段的初始化" class="headerlink" title="属性表集合—–静态field字段的初始化"></a>属性表集合—–静态field字段的初始化</h3><p>在定义field字段的过程中，我们有时候会很自然地对field字段直接赋值，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX=<span class="number">100</span>;  </div><div class="line"><span class="keyword">public</span>  <span class="keyword">int</span> count=<span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>对于虚拟机而言，上述的两个field字段赋值的时机是不同的：  </p>
<ul>
<li>对于非静态（即无static修饰）的field字段的赋值将会出现在实例构造方法<init>()中</init></li>
<li>对于静态的field字段，有两个选择：1、在静态构造方法<cinit>()中进行；2 、使用ConstantValue属性进行赋值</cinit></li>
</ul>
<blockquote>
<p>Sun javac编译器对于静态field字段的初始化赋值策略<br>目前的Sun javac编译器的选择是：如果使用final和static同时修饰一个field字段，并且这个字段是基本类型或者String类型的，那么编译器在编译这个字段的时候，会在<br>对应的field_info结构体中增加一个ConstantValue类型的结构体，在赋值的时候使用这个ConstantValue进行赋值；如果该field字段并没有被final修饰，或者不是基本<br>类型或者String类型，那么将在类构造方法&lt;<strong>cinit</strong>&gt;()中赋值。<br>对于上述的public static final init MAX=100;   javac编译器在编译此field字段构建field_info结构体时，除了访问标志、名称索引、描述符索引外，会增加一个ConstantValue类型的属性表。      </p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20141113154008360" alt=""></p>
<h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><p> 方法表集合是指由<strong>若干个方法表（method_info）组成的集合</strong>。对于在类中定义的若干个，经过JVM编译成class文件后，会将相应的method方法信息组织到一个叫做方法表集合的结构中，字段表集合是一个类数组结构，如下图所示：<br><img src="http://img.blog.csdn.net/20141114104145226" alt="">  </p>
<p>一个类中方法包含的信息<br><img src="http://img.blog.csdn.net/20141114150716551" alt=""></p>
<h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><p>记录方法的机器指令和抛出异常等信息属性表集合记录了某个方法的一些属性信息，这些信息包括：</p>
<ul>
<li>这个方法的代码实现，<strong>即方法的可执行的机器指令</strong></li>
<li>这个方法声明的要抛出的异常信息</li>
<li>这个方法是否被@deprecated注解表示</li>
<li>这个方法是否是编译器自动生成的</li>
</ul>
<h3 id="Code类型的属性表"><a href="#Code类型的属性表" class="headerlink" title="Code类型的属性表"></a>Code类型的属性表</h3><p>Code类型的属性表(attribute_info)可以说是class文件中最为重要的部分，因为它包含的是JVM可以运行的机器码指令，JVM能够运行这个类，就是从这个属性中取出机器码的。除了要执行的机器码，它还包含了一些其他信息，如下所示：</p>
<p><img src="http://img.blog.csdn.net/20141116114625218" alt=""></p>
<p>Code属性表的组成部分：</p>
<ul>
<li>机器指令—-code：<br>目前的JVM使用一个字节表示机器操作码，即对JVM底层而言，它能表示的机器操作码不多于2的 8 次方，即 256个。class文件中的机器指令部分是class文件中最重要的部分，并且非常复杂，本文的重点不止介绍它，我将专门在一片博文中讨论它，敬请期待。</li>
<li>异常处理跳转信息—exception_table：<br>如果代码中出现了try{}catch{}块，那么try{}块内的机器指令的地址范围记录下来，并且记录对应的catch{}块中的起始机器指令地址，当运行时在try块中有异常抛出的话，JVM会将catch{}块对应懂得其实机器指令地址传递给PC寄存器，从而实现指令跳转；</li>
<li>Java源码行号和机器指令的对应关系—LineNumberTable属性表：<br>编译器在将java源码编译成class文件时，会将源码中的语句行号跟编译好的机器指令关联起来，这样的class文件加载到内存中并运行时，如果抛出异常，JVM可以根据这个对应关系，抛出异常信息，告诉我们我们的源码的多少行有问题，方便我们定位问题。这个信息不是运行时必不可少的信息，但是默认情况下，编译器会生成这一项信息，如果你项取消这一信息，你可以使用-g:none 或-g:lines来取消或者要求设置这一项信息。如果使用了-g:none来生成class文件，class文件中将不会有LineNumberTable属性表，造成的影响就是 将来如果代码报错，将无法定位错误信息报错的行，并且如果项调试代码，将不能在此类中打断点（因为没有指定行号。）</li>
<li>局部变量表描述信息—-LocalVariableTable属性表：<br>局部变量表信息会记录栈帧局部变量表中的变量和java源码中定义的变量之间的关系，这个信息不是运行时必须的属性，默认情况下不会生成到class文件中。你可以根据javac指令的-g:none或者-g:vars选项来取消或者设置这一项信息。</li>
</ul>
<blockquote>
<p>引用来源：<a href="http://blog.csdn.net/luanlouis/article/details/41113695" target="_blank" rel="external">http://blog.csdn.net/luanlouis/article/details/41113695</a><br><a href="http://blog.csdn.net/u011080472/article/details/51326334" target="_blank" rel="external">http://blog.csdn.net/u011080472/article/details/51326334</a>   </p>
</blockquote>
<p>水淀粉</p>
<blockquote>
<p>测试新闻本</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/henjuese/henjuese.github.io.git/2017/06/05/jvm-class/" data-id="cj3y4c6n80000nify1zf3k17p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/06/15/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2017/06/08/jvm-jvm/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/06/05/jvm-class/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 bww<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>